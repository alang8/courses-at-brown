<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KDNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stars</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.ebussmanfkierzen.stars</a> &gt; <span class="el_source">KDNode.java</span></div><h1>KDNode.java</h1><pre class="source lang-java linenums">package edu.brown.cs.ebussmanfkierzen.stars;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

/**
 * Class representing a node in a kd tree.
 */
public class KDNode implements IKDTree {
  //fields representing the value, left, and right trees respectively.
  private Coordinate value;
  private IKDTree leftTree;
  private IKDTree rightTree;

  /**
   * Constructor for creating a node in our kd tree.
   * @param v - the value stored in the node.
   * @param l - the left subtree.
   * @param r - the right subtree.
   */
<span class="fc" id="L23">  public KDNode(Coordinate v, IKDTree l, IKDTree r) {</span>
<span class="fc" id="L24">    this.value = v;</span>
<span class="fc" id="L25">    this.leftTree = l;</span>
<span class="fc" id="L26">    this.rightTree = r;</span>
<span class="fc" id="L27">  }</span>

  @Override
  public Coordinate getVal() {
<span class="fc" id="L31">    return this.value;</span>
  }

  @Override
  public IKDTree getLeft() {
<span class="fc" id="L36">    return this.leftTree;</span>
  }

  @Override
  public IKDTree getRight() {
<span class="fc" id="L41">    return this.rightTree;</span>
  }

  @Override
  public void print(String lead) {
<span class="nc bnc" id="L46" title="All 2 branches missed.">    if (this.value != null) {</span>
<span class="nc" id="L47">      System.out.println(lead + &quot;- &quot; + this.value.getID());</span>
<span class="nc" id="L48">      lead = lead.substring(0, lead.length() - 1);</span>
<span class="nc" id="L49">      this.leftTree.print(lead + &quot;\tL&quot;);</span>
<span class="nc" id="L50">      this.rightTree.print(lead + &quot;\tR&quot;);</span>
    }
<span class="nc" id="L52">  }</span>


  /**
   * Method which builds a kd tree.
   * @param sL - the list of objects to build the tree out of.
   * @param dim - the dimensionality of the kd tree.
   * @param depth - the current depth of the kd tree.
   * @return - a kd tree filled with the objects in sL.
   */
  public static IKDTree buildTree(List&lt;? extends Coordinate&gt; sL, int dim, int depth) {
<span class="fc bfc" id="L63" title="All 2 branches covered.">    if (sL.isEmpty()) {</span>
<span class="fc" id="L64">      return new KDNode(null, null, null);</span>
    }

<span class="fc" id="L67">    int curAx = depth % dim;</span>

<span class="fc" id="L69">    sL.sort(Comparator.comparingDouble(s -&gt; s.getCoords().get(curAx)));</span>
<span class="fc" id="L70">    int listSz = sL.size();</span>
<span class="fc" id="L71">    int midIndex = listSz / 2;</span>
<span class="fc" id="L72">    Coordinate root = sL.get(midIndex);</span>

<span class="fc" id="L74">    List&lt;Double&gt; curCoors = root.getCoords();</span>

    //While loop so all &quot;equals&quot; are on the right
<span class="fc bfc" id="L77" title="All 2 branches covered.">    if (midIndex - 1 &gt;= 0) {</span>
<span class="fc" id="L78">      boolean hasNext = true;</span>
<span class="pc bpc" id="L79" title="2 of 4 branches missed.">      while (hasNext &amp;&amp; (curCoors.get(curAx).equals(sL.get(midIndex - 1).getCoords().get(curAx)))) {</span>
<span class="nc" id="L80">        curCoors = sL.get(midIndex - 1).getCoords();</span>
<span class="nc" id="L81">        midIndex -= 1;</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        hasNext = (midIndex - 1 &gt;= 0);</span>
      }
    }

<span class="fc" id="L86">    root = sL.get(midIndex);</span>

<span class="fc" id="L88">    List&lt;Coordinate&gt; leftSubList = (List&lt;Coordinate&gt;) sL.subList(0, midIndex);</span>
<span class="fc" id="L89">    List&lt;Coordinate&gt; rightSubList = (List&lt;Coordinate&gt;) sL.subList(midIndex + 1, listSz);</span>

<span class="fc" id="L91">    IKDTree leftSubTree = buildTree(leftSubList, dim, depth + 1);</span>
<span class="fc" id="L92">    IKDTree rightSubTree = buildTree(rightSubList, dim, depth + 1);</span>
<span class="fc" id="L93">    return new KDNode(root, leftSubTree, rightSubTree);</span>
  }


  /**
   * The actual kd tree neighbors algorithm - fills the priority queue with the nearest neighbors.
   * @param pq - priority queue ordered by furthest distance from source.
   * @param tr - the kd tree of stars.
   * @param source - arraylist containing the coordinates of the source.
   * @param curAx - the current axis we are querying.
   * @param numNeighbors - then number of neighbors we are interested in.
   */
  public static void kdnAlg(PriorityQueue&lt;Coordinate&gt; pq, IKDTree tr, List&lt;Double&gt; source, int curAx, int numNeighbors) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">    if (tr.getVal() == null) {</span>
<span class="fc" id="L107">      return;</span>
    }
<span class="fc" id="L109">    Coordinate root = (Coordinate) tr.getVal();</span>
<span class="fc" id="L110">    Coordinate curWorst = pq.peek();</span>

<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (pq.size() &lt; numNeighbors) {</span>
<span class="fc" id="L113">      pq.add(root);</span>
<span class="fc" id="L114">      curAx = (curAx + 1) % (source.size());</span>
<span class="fc" id="L115">      kdnAlg(pq, tr.getRight(), source, curAx, numNeighbors);</span>
<span class="fc" id="L116">      kdnAlg(pq, tr.getLeft(), source, curAx, numNeighbors);</span>
<span class="fc" id="L117">      return;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">    } else if (root.distanceFrom(source) &lt; curWorst.distanceFrom(source)) {</span>
<span class="fc" id="L119">      pq.poll();</span>
<span class="fc" id="L120">      pq.add(root);</span>
    }

<span class="fc" id="L123">    curWorst = pq.peek();</span>
<span class="fc" id="L124">    List&lt;Double&gt; rootCoods = root.getCoords();</span>
<span class="fc" id="L125">    double worstDistance = curWorst.distanceFrom(source);</span>
<span class="fc" id="L126">    double axisDistance = Math.abs(rootCoods.get(curAx) - source.get(curAx));</span>

<span class="pc bpc" id="L128" title="1 of 2 branches missed.">    if (worstDistance &gt; axisDistance) {</span>
      //recur on both
<span class="fc" id="L130">      curAx = (curAx + 1) % (source.size());</span>
<span class="fc" id="L131">      kdnAlg(pq, tr.getRight(), source, curAx, numNeighbors);</span>
<span class="fc" id="L132">      kdnAlg(pq, tr.getLeft(), source, curAx, numNeighbors);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">    } else if (rootCoods.get(curAx) &lt; source.get(curAx)) {</span>
<span class="nc" id="L134">      curAx = (curAx + 1) % (source.size());</span>
<span class="nc" id="L135">      kdnAlg(pq, tr.getRight(), source, curAx, numNeighbors);</span>
    } else {
<span class="nc" id="L137">      curAx = (curAx + 1) % (source.size());</span>
<span class="nc" id="L138">      kdnAlg(pq, tr.getLeft(), source, curAx, numNeighbors);</span>
    }
<span class="fc" id="L140">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>