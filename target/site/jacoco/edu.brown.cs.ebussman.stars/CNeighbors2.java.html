<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CNeighbors2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">stars</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.ebussman.stars</a> &gt; <span class="el_source">CNeighbors2.java</span></div><h1>CNeighbors2.java</h1><pre class="source lang-java linenums">package edu.brown.cs.ebussman.stars;

import java.util.LinkedList;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Collections;

public class CNeighbors2&lt;T extends Coordinate&gt; implements Command {

  private LinkedList&lt;Coordinate&gt; neighborList;
  private Map&lt;Coordinate, Double&gt; neighborDistances;
  private double worstDistance;
  private int k;
  private int maxDepth;
  private KDTree&lt;Coordinate&gt; tree;
  private List&lt;Coordinate&gt; duplicates;
  private double duplicateDist;
  private Map&lt;Coordinate, Boolean&gt; inDuplicates;
  private List&lt;String&gt; results;
  private List&lt;Double&gt; target;
  private String targetName;
  private Application app;


<span class="fc" id="L28">  public CNeighbors2() {</span>
<span class="fc" id="L29">  }</span>

<span class="fc" id="L31">  public CNeighbors2(LinkedList&lt;Coordinate&gt; neighborList, Map&lt;Coordinate, Double&gt; neighborDistances, int k) {</span>
<span class="fc" id="L32">    this.neighborList = neighborList;</span>
<span class="fc" id="L33">    this.neighborDistances = neighborDistances;</span>
<span class="fc" id="L34">    this.duplicates = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L35">    this.inDuplicates = new HashMap&lt;&gt;();</span>
<span class="fc" id="L36">    this.worstDistance = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L37">    this.k = k;</span>
<span class="fc" id="L38">  }</span>

  /**
   * execute: method which finds the n nearest neighbors to a given origin star.
   *
   * @param inputs an array of search criteria inputted by user
   * @param appl   the application holding the data the user wishes to search through
   * @return A list of strings representing the Star objects that are nearest
   * to the origin and fit the requirements of &quot;inputs&quot;
   **/
  public List&lt;String&gt; execute(String[] inputs, Application appl) {

<span class="fc" id="L50">    this.app = appl;</span>
<span class="fc" id="L51">    this.target = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L52">    this.results = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">    if (!app.isDataLoaded()) {</span>
<span class="nc" id="L54">      System.out.println(&quot;ERROR: no loaded data&quot;);</span>
<span class="nc" id="L55">      results.add(&quot;ERROR: no loaded data&quot;);</span>
<span class="nc" id="L56">      return results;</span>
<span class="pc bpc" id="L57" title="3 of 4 branches missed.">    } else if (!(inputs.length == 5 || inputs.length == 3)) {</span>
<span class="nc" id="L58">      System.out.println(&quot;ERROR: incorrect number of arguments for naive_neighbors&quot;);</span>
<span class="nc" id="L59">      results.add(&quot;ERROR: incorrect number of arguments for naive_neighbors&quot;);</span>
<span class="nc" id="L60">      return results;</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">    } else if (Integer.parseInt(inputs[1]) &lt; 0) {</span>
<span class="fc" id="L62">      System.out.println(&quot;ERROR: neighbors must be non-negative&quot;);</span>
<span class="fc" id="L63">      results.add(&quot;ERROR: neighbors must be non-negative&quot;);</span>
<span class="fc" id="L64">      return results;</span>
    }
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">    if (inputs.length == 5) {</span>
      try {
<span class="fc" id="L68">        target.add(Double.parseDouble(inputs[2]));</span>
<span class="fc" id="L69">        target.add(Double.parseDouble(inputs[3]));</span>
<span class="fc" id="L70">        target.add(Double.parseDouble(inputs[4]));</span>
<span class="nc" id="L71">      } catch (Exception e) {</span>
<span class="nc" id="L72">        System.out.println(&quot;ERROR: coordinates must be numeric values&quot;);</span>
<span class="nc" id="L73">        results.add(&quot;ERROR: coordinates must be numeric values&quot;);</span>
<span class="nc" id="L74">        return results;</span>
<span class="fc" id="L75">      }</span>
<span class="fc" id="L76">      targetName = &quot;nothing&quot;;</span>
    } else {
<span class="nc" id="L78">      Coordinate coord = app.findTargetByName(inputs[2]);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">      if (coord != null) {</span>
        //searchByName = true;
<span class="nc" id="L81">        this.targetName = coord.getName();</span>
<span class="nc" id="L82">        target = coord.getCoords();</span>
      } else {
<span class="nc" id="L84">        System.out.println(&quot;ERROR: cannot find this star by name&quot;);</span>
<span class="nc" id="L85">        results.add(&quot;ERROR: cannot find this star by name&quot;);</span>
<span class="nc" id="L86">        return results;</span>
      }
    }

<span class="fc" id="L90">    this.k = Integer.parseInt(inputs[1]);</span>
<span class="fc" id="L91">    this.maxDepth = app.getDimension() - 1;</span>
<span class="fc" id="L92">    this.neighborList = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L93">    this.neighborDistances = new HashMap&lt;&gt;();</span>
<span class="fc" id="L94">    this.tree = this.app.getData();</span>
<span class="fc" id="L95">    this.duplicates = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L96">    this.inDuplicates = new HashMap&lt;&gt;();</span>

    //keeps track of the furthest distance in current neighbors list
<span class="fc" id="L99">    this.worstDistance = Double.NEGATIVE_INFINITY;</span>

<span class="fc" id="L101">    nearestNeighbor(this.tree, this.maxDepth);</span>

    //fix potential tie cases if necessary
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">    if (duplicates.size() &gt; 0) {</span>
<span class="nc" id="L105">      fixTies();</span>
    }

<span class="fc bfc" id="L108" title="All 2 branches covered.">    for (Coordinate item : neighborList) {</span>
<span class="fc" id="L109">      System.out.println(item.getID());</span>
<span class="fc" id="L110">      results.add(item.toString());</span>
<span class="fc" id="L111">    }</span>
<span class="fc" id="L112">    return results;</span>
  }

  //want to find nearest neighbors to target point (node is current split)

  /**
   * nearestNeighbor method: finds the k closest items to the target item.
   *
   * @param currentTree: the current KD-tree through which to search for
   *                     nearest neighbors
   * @param depth:       the current axes on which to compare coordinates
   *                     (x is depth 0, y is depth 1, z is depth 2, for example)
   */
  public void nearestNeighbor(KDTree&lt;Coordinate&gt; currentTree, int depth) {

    //base case
<span class="fc bfc" id="L128" title="All 2 branches covered.">    if (currentTree == null) {</span>
<span class="fc" id="L129">      return;</span>
    }

<span class="fc bfc" id="L132" title="All 2 branches covered.">    if (depth == -1) {</span>
<span class="fc" id="L133">      depth = this.maxDepth;</span>
    }

    //get Euclidean distance
<span class="fc" id="L137">    double straightDist = this.app.distance(currentTree.getVal().getCoords(), target);</span>

    //neighbor list isn't full yet
<span class="pc bpc" id="L140" title="1 of 4 branches missed.">    if (neighborList.size() &lt; this.k &amp;&amp; !targetName.equals(currentTree.getVal().getName())) {</span>

<span class="fc bfc" id="L142" title="All 4 branches covered.">      if (neighborList.size() == 0 || straightDist &gt; worstDistance) {</span>
<span class="fc" id="L143">        this.neighborList.add(currentTree.getVal());</span>
<span class="fc" id="L144">        this.neighborDistances.put(currentTree.getVal(), straightDist);</span>
<span class="fc" id="L145">        this.worstDistance = straightDist;</span>
      } else {
        //adds items in order so we don't have to sort list every time
        // and can just check distance of furthest, nearest neighbor
<span class="fc" id="L149">        this.neighborDistances.put(currentTree.getVal(), straightDist);</span>
<span class="fc" id="L150">        addToList(currentTree.getVal(), straightDist);</span>
      }
      // save distance for later so we don't re-calculate
<span class="fc" id="L153">      this.neighborDistances.put(currentTree.getVal(), straightDist);</span>

      //list is full here
      //make sure we don't add the target point
<span class="pc bpc" id="L157" title="3 of 4 branches missed.">    } else if (straightDist &lt;= worstDistance &amp;&amp; !targetName.equals(currentTree.getVal().getName())) {</span>
<span class="nc" id="L158">      this.neighborDistances.put(currentTree.getVal(), straightDist);</span>
<span class="nc" id="L159">      addToList(currentTree.getVal(), straightDist);</span>
<span class="nc" id="L160">      this.neighborDistances.put(currentTree.getVal(), straightDist);</span>
    }

    //find the relevant axis according to the depth
<span class="fc" id="L164">    double axialDist = Math.abs(target.get(depth) - currentTree.getVal().getCoords().get(depth));</span>
<span class="pc bpc" id="L165" title="1 of 4 branches missed.">    if (this.worstDistance &gt;= axialDist || neighborList.size() &lt; k) {</span>
      //recur on both children
<span class="fc" id="L167">      nearestNeighbor(currentTree.getLeft(), depth - 1);</span>
<span class="fc" id="L168">      nearestNeighbor(currentTree.getRight(), depth - 1);</span>
    } else {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">      if (target.get(depth) &gt;= currentTree.getVal().getCoords().get(depth)) {</span>
        //recur on right subtree
<span class="fc" id="L172">        nearestNeighbor(currentTree.getRight(), depth - 1);</span>
      } else {
        //recur on left subtree
<span class="nc" id="L175">        nearestNeighbor(currentTree.getLeft(), depth - 1);</span>
      }
    }
<span class="fc" id="L178">  }</span>

  /**
   * addToList: adds a coordinate to nearest neighbors list in the correct (sorted) position.
   *
   * @param node:     the current node to be added to the list of nearest neighbors
   * @param nodeDist: the distance from the current node to the target node
   */
  public void addToList(Coordinate node, Double nodeDist) {

<span class="fc" id="L188">    boolean added = false;</span>
<span class="fc" id="L189">    Iterator&lt;Coordinate&gt; it = neighborList.iterator();</span>
<span class="fc" id="L190">    int i = 0;</span>

<span class="fc bfc" id="L192" title="All 4 branches covered.">    while (!added &amp;&amp; it.hasNext()) {</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">      if (nodeDist &lt;= neighborDistances.get(it.next())) {</span>
<span class="fc" id="L194">        neighborList.add(i, node);</span>
<span class="fc" id="L195">        int size = neighborList.size();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (size &gt; this.k) {</span>
<span class="fc" id="L197">          Coordinate removed = neighborList.removeLast();</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">          if (neighborDistances.get(removed) == nodeDist) {</span>
<span class="nc" id="L199">            this.duplicateDist = nodeDist;</span>
<span class="nc" id="L200">            duplicates.add(node);</span>
<span class="nc" id="L201">            inDuplicates.put(node, true);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            if (!inDuplicates.get(removed)) {</span>
<span class="nc" id="L203">              duplicates.add(removed);</span>
            }
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">          } else if (neighborDistances.get(removed) != neighborDistances.get(neighborList.getLast())) {</span>
<span class="fc" id="L206">            duplicates.clear();</span>
          }
        }

        //update worst element
<span class="fc" id="L211">        this.worstDistance = neighborDistances.get(neighborList.getLast());</span>
<span class="fc" id="L212">        added = true;</span>

<span class="fc" id="L214">      } else {</span>
<span class="fc" id="L215">        i++;</span>
      }
    }

<span class="fc" id="L219">  }</span>

  /**
   * fixTies: method that edits the list of nearest neighbors
   * to replace duplicate items (same distance to target) with
   * random duplicates.
   */
  public void fixTies() {

    //won't error because we know duplicates has at least one item
<span class="nc" id="L229">    double duplicateVal = neighborDistances.get(duplicates.get(0));</span>
    //index of last item in neighbor list;
<span class="nc" id="L231">    int i = k - 1;</span>
<span class="nc" id="L232">    int j = 0;</span>
<span class="nc" id="L233">    Collections.shuffle(duplicates);</span>

    // iterate backwards through list of nearest neighbors, replacing
    // duplicates with random duplicates until the items are unique
<span class="nc bnc" id="L237" title="All 4 branches missed.">    while (i &gt; -1 &amp;&amp; neighborDistances.get(neighborList.get(i)) == duplicateVal) {</span>
<span class="nc" id="L238">      neighborList.set(i, duplicates.get(j));</span>
<span class="nc" id="L239">      i--;</span>
<span class="nc" id="L240">      j++;</span>
    }

<span class="nc" id="L243">  }</span>

  public void setTarget(List&lt;Double&gt; coords) {
<span class="fc" id="L246">    this.target = coords;</span>
<span class="fc" id="L247">  }</span>

  public List&lt;Coordinate&gt; getResults() {
<span class="fc" id="L250">    return this.neighborList;</span>
  }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>